# 并发相关的常见问题

## 我想让线程 A 依赖于线程 B 的执行结果，应该怎么做？
- **使用Thread.join()**：如果线程B的执行结果存储在某个变量中，线程A可以调用`B.join()`等待线程B结束，然后访问该变量。
- **使用 CountDownLatch**：可以创建一个 `CountDownLatch`，线程 B 在执行完毕后调用 `countDown()` 方法，线程 A 在调用 `await()` 方法时会阻塞，直到线程 B 执行完毕。
- **使用 Future**：可以使用线程池提交线程 B 的任务，线程 A 可以通过 `Future.get()` 获取线程 B 的执行结果，在获取到结果后继续执行。
- **使用BlockingQueue**：线程B将结果放入阻塞队列，线程A从队列中取出结果，如果队列为空则阻塞。

## 如何实现线程间的通信？
- **使用共享变量**：线程可以通过共享变量进行通信，例如使用 `volatile` 关键字修饰的变量，确保线程间的可见性。
- **使用 wait() 和 notify()**：在一个线程中调用 `wait()` 方法可以使线程进入等待状态，直到其他线程调用 `notify()` 或 `notifyAll()` 方法唤醒它。
- **使用BlockingQueue**：线程可以通过阻塞队列进行通信，生产者线程将数据放入队列，消费者线程从队列中取出数据。
- **使用信号量**：可以使用 `Semaphore` 类来实现线程间的通信，允许多个线程访问共享资源。
- **使用 CountDownLatch**：可以使用 `CountDownLatch` 类来实现线程间的通信，允许一个或多个线程等待其他线程。

## 用过 ThreadLocal 吗？它的工作原理是什么？
ThreadLocal 可以为每个线程独立存储数据，保证线程安全。  
- 工作原理：ThreadLocal的工作原理是为每个线程维护一个 ThreadLocalMap，当调用 set 或 get 方法时，它将当前的ThreadLocal实例作为 key，要保存的数据作为 value。
- 内存泄漏问题：由于 ThreadLocalMap 的 key 是一个弱引用，所以如果 ThreadLocal 实例被回收，但是当前 Thread 没有结束，这个 value 就不会被回收，造成内存泄露，所以在使用完 ThreadLocal 后一定要手动调用 remove 方法回收 value

## 什么是阻塞队列，举几个应用场景？
### 概念
阻塞队列常应用于多线程环境中实现线程之间的通信。特点是当队列为空时，从队列中取元素的操作会阻塞，当队列满了的时候，想队列插入数据的操作会被阻塞
- ArrayBlockingQueue 有界队列
- LinkedBlockingQueue 无界队列
- PriorityBlockingQueue FIFO队列
### 应用场景
- 生产者消费者模型
- 线程池的任务队列
- 线程同步，当线程A依赖于线程B的结果，可以使用阻塞队列，当队列为空时，线程A被阻塞，当线程B将结果写到阻塞队列后，线程A才会被激活。

## 创建一个线程，需要占用多少内存？
创建线程时，会给这个线程单独分配一个虚拟机栈，线程消耗的内存主要就是这个大小，虚拟机中默认的栈大小为1m，可以使用Xss来设置。

## 如果线程A依赖于线程B，可以用什么方法实现？
1. Thread.join()
2. Future + ExecutorService
3. CompletableFuture
4. CountDownLatch
5. BlockingQueue
6. 回调方法

## 当请求数超过核心线程数会发生什么？超过最大线程数呢？
当请求数超过核心线程数时，线程池会将多余的任务放入任务队列中等待执行。
如果任务队列也满了，且当前线程数还没有达到最大线程数，线程池会创建新的线程来处理这些任务，直到达到最大线程数为止。
如果任务队列满了且当前线程数已经达到了最大线程数，那么根据饱和策略（RejectedExecutionHandler），线程池会采取相应的措施来处理这些无法执行的任务，例如抛出异常、丢弃任务、调用任务的 run 方法等。