# 并发知识总结

## JMM模型
JMM（Java内存模型）是Java虚拟机规范的一部分，定义了Java程序中变量（线程共享变量）的访问规则，以及在并发环境下如何保证变量的可见性、有序性和原子性。
### 主要概念
1. **线程工作内存**：每个线程都有自己的工作内存，存储该线程使用的变量副本。
2. **主内存**：所有线程共享的内存区域，存储所有的实例字段、静态字段和数组元素。
3. **内存交互操作**：线程与主内存之间通过一系列操作（如lock、unlock、read、write等）来进行数据的读写。
### 关键特性
1. **可见性**：当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。
2. **有序性**：程序执行的顺序按照代码的先后顺序执行，但在多线程环境下，编译器和处理器可能会对指令进行重排序。
3. **原子性**：某些操作是不可分割的，要么全部执行成功，要么全部不执行。
### JMM中的happens-before原则
1. 程序顺序规则：一个线程内的操作按程序顺序执行，前面的操作happens-before后面的操作。

## 乐观锁和悲观锁
### 乐观锁
- 特点：先修改，提交时检查冲突，适用于读操作多的场景，实现比较复杂，但并发性能高
- 实现方式：
  - 1.版本号机制：在表中添加一个版本号字段（如version），读取数据时同时获取版本号，更新数据时检查版本号是否变化
  - 2.条件检查：不添加额外字段，而是在where条件中检查所有或关键字段是否变化
  - 3.JPA在可以在应用层实现乐观锁
### 悲观锁
- 特点：先获取锁，再访问数据，适用于写操作多的场景，实现简单，但并发性能较低
- 实现方式：
  - 数据库：SELECT ... FOR UPDATE
  - Java：synchronized关键字、ReentrantLock等

## CAS
CAS 是一种无锁（Lock-Free）算法，通过硬件指令（如 x86 的 CMPXCHG）保证操作的原子性。
- **操作逻辑**：比较当前值（expectedValue）与内存中的值是否一致： 如果一致，则将新值（newValue）写入内存；如果不一致，则操作失败（通常通过自旋重试）。
- **优点**
  - 高性能：无锁操作减少线程阻塞，适合高并发场景。
  - 线程安全：避免使用 synchronized 的开销。
- **缺点**
  - ABA 问题：其他线程可能将值从 A 改为 B 又改回 A，CAS 无法感知中间变化。解决方案：使用 AtomicStampedReference 添加版本号。
  - 自旋开销：高竞争场景下，CAS 失败重试可能导致 CPU 占用过高。

## 死锁
### 死锁的形成条件
1. 互斥条件。一个资源同一时间只能由一个进程拥有。
2. 保持与请求。一个进程已经持有一部分资源，还需要请求另一部分资源
3. 不剥夺条件。进程已经拥有的资源，只能由自身释放，别的线程不允许剥夺
4. 环路等待条件。多个进程拥有的资源和请求的资源形成一个环形等待链。
### 解决死锁的方式
1. **预防死锁**  
总体来说，就是破坏死锁形成的条件。
- 资源一次性分配。预先整理进程所需的所有资源，等待所有资源都准备好，一次性获取。
- 资源可剥夺。当进程无法获取其他资源时，将已经拥有的资源释放掉。
- 资源有序分配。给资源进行编号，不同的进程使用相同的顺序获取资源。
2. **避免死锁**  
- 银行家算法
3. **检测与恢复**  
允许死锁发生，但定期检测并解除：
- 死锁检测算法：通过资源分配图（Resource Allocation Graph, RAG）检测环路。
- 恢复方法
  - 终止进程：强制终止部分进程（如优先级最低的进程）。
  - 资源回退：回滚进程到安全状态（需保存检查点）。