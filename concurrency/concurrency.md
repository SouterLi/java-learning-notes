# 并发知识总结

## AQS
AQS，抽象队列同步器，它是实现ReentrantLock和CountDownLatch的关键。
AQS维护了一个资源和资源状态，还有一个FIFO的队列，资源状态是使用volatile关键字修饰的，为了保证资源的可见性。
### 实现ReentrantLock和CountDownLatch
#### ReentrantLock
以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。
#### CountDownLatch
再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

## 乐观锁和悲观锁
### 乐观锁
- 特点：先修改，提交时检查冲突，适用于读操作多的场景，实现比较复杂，但并发性能高
- 实现方式：
  - 1.版本号机制：在表中添加一个版本号字段（如version），读取数据时同时获取版本号，更新数据时检查版本号是否变化
  - 2.条件检查：不添加额外字段，而是在where条件中检查所有或关键字段是否变化
  - 3.JPA在可以在应用层实现乐观锁
### 悲观锁
- 特点：先获取锁，再访问数据，适用于写操作多的场景，实现简单，但并发性能较低
- 实现方式：
  - 数据库：SELECT ... FOR UPDATE
  - Java：synchronized关键字、ReentrantLock等

## CAS
CAS 是一种无锁（Lock-Free）算法，通过硬件指令（如 x86 的 CMPXCHG）保证操作的原子性。
- **操作逻辑**：比较当前值（expectedValue）与内存中的值是否一致： 如果一致，则将新值（newValue）写入内存；如果不一致，则操作失败（通常通过自旋重试）。
- **优点**
  - 高性能：无锁操作减少线程阻塞，适合高并发场景。
  - 线程安全：避免使用 synchronized 的开销。
- **缺点**
  - ABA 问题：其他线程可能将值从 A 改为 B 又改回 A，CAS 无法感知中间变化。解决方案：使用 AtomicStampedReference 添加版本号。
  - 自旋开销：高竞争场景下，CAS 失败重试可能导致 CPU 占用过高。

## 死锁
### 死锁的形成条件
1. 互斥条件。一个资源同一时间只能由一个进程拥有。
2. 保持与请求。一个进程已经持有一部分资源，还需要请求另一部分资源
3. 不剥夺条件。进程已经拥有的资源，只能由自身释放，别的线程不允许剥夺
4. 环路等待条件。多个进程拥有的资源和请求的资源形成一个环形等待链。
### 解决死锁的方式
1. **预防死锁**  
总体来说，就是破坏死锁形成的条件。
- 资源一次性分配。预先整理进程所需的所有资源，等待所有资源都准备好，一次性获取。
- 资源可剥夺。当进程无法获取其他资源时，将已经拥有的资源释放掉。
- 资源有序分配。给资源进行编号，不同的进程使用相同的顺序获取资源。
2. **避免死锁**  
- 银行家算法
3. **检测与恢复**  
允许死锁发生，但定期检测并解除：
- 死锁检测算法：通过资源分配图（Resource Allocation Graph, RAG）检测环路。
- 恢复方法
  - 终止进程：强制终止部分进程（如优先级最低的进程）。
  - 资源回退：回滚进程到安全状态（需保存检查点）。