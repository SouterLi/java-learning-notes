# 几种常见的锁

## 1.synchronized关键字
### synchronized在Java1.6做了哪些优化？
在Java 1.6中，`synchronized`关键字进行了多项优化，以提高性能和减少锁竞争。主要的优化包括：
1. **偏向锁**：在没有竞争的情况下，锁会偏向于第一个获取锁的线程，避免了每次获取锁都需要进行CAS操作。偏向锁会在锁的头部记录线程ID，当同一线程再次获取锁时，可以直接获取锁而不需要进行CAS操作。
2. **轻量级锁**：当有多个线程竞争同一个锁时，偏向锁会被撤销，转为轻量级锁。轻量级锁使用CAS操作来尝试获取锁，如果获取成功，则不会阻塞其他线程，减少了上下文切换的开销。
3. **自旋锁**：当轻量级锁竞争失败时，线程会自旋一段时间，尝试再次获取锁，而不是直接阻塞。这可以减少线程切换的开销，特别是在锁竞争较少的情况下。
4. **锁消除**：编译器会在编译时分析代码，消除不必要的锁操作。例如，如果一个对象只在单线程环境中使用，编译器可以优化掉对该对象的锁操作。
5. **锁粗化**：编译器会将多个连续的锁操作合并为一个锁操作，减少锁的获取和释放次数，从而提高性能。
6. **逃逸分析**：JVM会分析对象的使用范围，如果发现对象没有逃逸出方法的作用域，则可以优化掉对该对象的锁操作，从而减少锁的开销。
### synchronized锁升级过程
`synchronized`锁的升级过程主要包括以下几个阶段：
1. **无锁状态**：当一个线程第一次访问同步代码块时，JVM会为该对象分配一个无锁状态的标志位。
2. **偏向锁**：如果没有其他线程竞争该锁，JVM会将锁标记为偏向锁，并记录获取锁的线程ID。此时，线程可以直接进入同步代码块，而不需要进行CAS操作。
3. **轻量级锁**：当有其他线程尝试获取偏向锁时，偏向锁会被撤销，转为轻量级锁。此时，JVM会使用CAS操作尝试获取锁，如果获取成功，则进入同步代码块；如果获取失败，则进入自旋状态，尝试再次获取锁。
4. **重量级锁**：如果轻量级锁竞争激烈，线程无法获取锁，JVM会将轻量级锁升级为重量级锁。此时，线程会被阻塞，直到获取到锁为止。重量级锁会使用操作系统的互斥量（mutex）来实现同步，这会导致线程上下文切换的开销增加。
5. **锁释放**：当所有的线程执行完同步代码块后，会释放锁。此时重新进入无锁状态。
### synchronized关键字一定保证线程安全吗？
不一定。
当一个静态方法和一个实例方法对同一个数据进行操作时，二者都加上synchronized，也不能保证最终结果正确，因为synchronized是通过进入和退出管程对象（Monitor）来实现同步的。静态方法和实例方法的monitor不是同一个。

## 2.ReentrantLock
ReentrantLock，可重入锁，可以实现和synchronized类似的功能，但是比synchronized可以实现更多的功能，使用也更加灵活。  
ReentrantLock实现了Lock接口，通过内部类继承了AQS类，和cas操作，实现了重入锁的功能。  
ReentrantLock有两种构造方法，默认的构造方法实现的是非公平锁，可以通过传入一个布尔值true，来实现公平锁。  
### 获取锁的过程
获取锁的方法是tryAcquire()，当调用tryAcquire()方法时，检查state，如果为0，表示锁未被占用，尝试占用，如果state>0，判断已经占用锁的线程是否是自己，如果是，state+1，如果不是，则获取锁失败，返回false。
### ReentrantLock的公平锁和非公平锁分别是怎样的？
**非公平锁**，当线程A占用锁的时候，会将锁状态置为1，线程B来的时候发现锁状态为1，就进入队列等候；A释放锁，将锁状态置为0，去尝试唤醒B，此时刚好C尝试获取锁，发现锁状态为0，锁获取成功，将锁置为1，B发现锁还是1，继续等待；  
**公平锁**，在C尝试获取锁的时候，不止要判断锁状态，还会判断等待队列是否为空，发现队列中有B，就不会尝试获取锁，而是直接进入队列，B就会拿到锁，遵循先进先出的原则。  
所以非公平锁其实不是随机一个线程获取到锁，它也是有队列的。
### synchronized和ReentrantLock的区别
1. **实现方式**：
   - `synchronized`是Java语言内置的关键字，直接通过JVM实现。
   - `ReentrantLock`是Java提供的一个类，实现了`Lock`接口，通过AQS（AbstractQueuedSynchronizer）实现。
2. **功能**：
   - `synchronized`只能用于方法或代码块的同步，不能实现更复杂的同步控制。
   - `ReentrantLock`提供了更多的功能，如可重入、可中断、超时获取锁、公平锁和非公平锁等。
3. **性能**：
   - `synchronized`在Java 1.6及以后版本进行了优化，性能已经大幅提升，但在高竞争场景下仍然可能存在性能问题。
   - `ReentrantLock`在高竞争场景下通常表现更好，因为它使用了非阻塞的CAS操作和自旋锁机制，可以减少线程上下文切换的开销。
4. **锁的释放**：
   - `synchronized`在方法执行完毕或代码块执行完毕后自动释放锁。
   - `ReentrantLock`需要手动调用`unlock()`方法来释放锁，如果没有正确释放锁，可能会导致死锁。
5. **可中断性**：
   - `synchronized`无法响应中断，如果一个线程在等待获取锁时被中断，它会一直等待下去。
   - `ReentrantLock`提供了可中断的获取锁方法，如`lockInterruptibly()`，可以在等待锁时响应中断。
6. **公平性**：
   - `synchronized`是非公平锁，无法保证线程获取锁的顺序。
   - `ReentrantLock`可以选择公平锁或非公平锁，公平锁可以保证线程获取锁的顺序。
7. **条件变量**：
   - `synchronized`可以通过`wait()`、`notify()`和`notifyAll()`方法实现条件变量。
   - `ReentrantLock`提供了`Condition`接口，可以实现更灵活的条件变量机制，支持多个条件变量。

## 3.volatile关键字
`volatile`关键字是Java中的一个修饰符，用于修饰变量。它的主要作用是确保变量在多线程环境中的可见性和禁止指令重排序。
### volatile的作用
1. **可见性**：当一个线程修改了被`volatile`修饰的变量时，其他线程可以立即看到这个修改。`volatile`变量的值在主内存中是可见的，其他线程读取时会从主内存中获取最新的值，而不是从线程的本地缓存中获取。
2. **禁止指令重排序**：`volatile`变量的读写操作不会被编译器和JVM进行指令重排序优化。这意味着在对`volatile`变量的读写操作之前和之后的代码不会被重排序，从而保证了操作的顺序性。
### 如何保证可见性
现代的CPU遵循缓存一致性协议，cpu会通过嗅探总线的数据和自己缓存中的数据进行比对，如果不一致，就将自身缓存中的值进行失效处理。当需要对数据进行改变时，会从总线上重新读取数据到缓存中。
volatile关键字实现了两个操作：
1.Lock指令导致修改的值立即回写到总线
处理器遇到lock指令时，会检查数据所在的内存区域，如果该数据是在处理器的内部缓存中，则会锁定此缓存区域，处理完后把缓存写回到主存中，并且会利用缓存一致性协议来保证其他处理器中的缓存数据的一致性。
2.由于缓存一致性协议的存在，一个处理器的回写操作会导致其他处理器的缓存失效
### 如何保证顺序性
volatile关键字通过插入硬件级的内存屏障来禁止指令重排序。  
在写之前加StoreStore 屏障，禁止上面普通写与volatile写重排序，在写之后加StoreLoad 屏障，禁止volatile写与后面的操作重排序。  
在读之后加LoadLoad屏障和LoadStore屏障，禁止下面的普通读写与volatile读重排序。
### volatile的使用
`volatile`通常用于以下场景：
1. **状态标志**：用于表示某个状态的标志位，例如线程是否停止的标志。
2. **双重检查锁定**：在单例模式中，使用`volatile`修饰实例变量，确保在多线程环境下的正确性。
3. **共享变量**：在多线程环境中，多个线程需要共享某个变量时，可以使用`volatile`来确保变量的可见性。
