# Java核心技术

## Java区别于其他语言的特点有哪些？
- 1.跨平台
- 2.垃圾回收机制
- 3.生态系统丰富
- 4.纯面向对象

## 反射
### 反射的定义
反射是指程序在运行时可以获取自身的信息，并且可以操作这些信息的能力。Java 反射机制允许程序在运行时查询类的信息、创建对象、调用方法以及访问字段等。
### 反射常用的方法
#### 获取类的信息
- `Class.forName("类的全限定名")`：通过类的全限定名获取 Class 对象。
- `类名.class`：通过类名直接获取 Class 对象。
- `对象.getClass()`：通过对象实例获取 Class 对象。
#### 创建对象
- `Class.newInstance()`：通过 Class 对象创建一个新的实例（需要类有无参构造方法）。
- `Constructor.newInstance(参数)`：通过 Constructor 对象创建一个新的实例，可以传入参数。
#### 访问字段
- `Field.get(Object obj)`：获取指定对象的字段值。
- `Field.set(Object obj, Object value)`：设置指定对象的字段值。
- `Field.getType()`：获取字段的类型。
#### 调用方法
- `Method.invoke(Object obj, Object... args)`：调用指定对象的方法，可以传入参数。
- `Method.getParameterTypes()`：获取方法的参数类型。
- `Method.getReturnType()`：获取方法的返回类型。
### 反射的原理
Java 反射机制是通过 `java.lang.reflect` 包中的类来实现的。每个类在加载时，JVM 会为其创建一个 `Class` 对象，这个对象包含了类的结构信息（如字段、方法、构造方法等）。通过这个 `Class` 对象，程序可以在运行时动态地获取和操作类的信息。
反射的实现依赖于 JVM 的类加载机制，当一个类被加载时，JVM 会将类的字节码转换为 `Class` 对象，并将其存储在方法区中。反射机制通过这些 `Class` 对象提供了对类的动态访问能力。
### 反射的性能问题
由于反射需要在运行时解析类的信息，因此相较于直接调用方法或访问字段，反射的性能开销较大。此外，反射操作通常会绕过 Java 的访问控制检查，这可能导致安全问题。  
因此，在性能敏感的场景中，应尽量避免使用反射，或者在使用反射时进行性能优化，例如缓存反射结果、减少反射调用次数等。
### 反射的安全性
反射机制允许程序在运行时动态地访问和修改类的结构，这可能会导致安全问题。例如，反射可以绕过访问控制检查，访问私有字段和方法，从而破坏封装性。  
为了提高反射的安全性，Java 提供了安全管理器（Security Manager），可以通过配置安全策略来限制反射操作。此外，在使用反射时，应遵循最佳实践，避免暴露敏感信息和操作。

### 泛型
#### 泛型的好处
1. 类型安全：编译时检查类型，避免运行时类型转换异常
2. 代码复用：可以编写通用的代码，处理多种类型
3. 可读性：代码更清晰，避免了强制类型转换
4. 性能优化：减少了类型转换的开销，提高了性能
#### 泛型的使用场景有哪些？
1. 集合容器（最常用），让集合只能存放指定类型，避免类型混乱
2. 工具方法，写一个方法能处理多种类型
3. 接口/类设计，设计通用的组件
4. 避免重复代码，当多个方法逻辑相同只是类型不同时，可以用泛型代替入参
#### 泛型擦除
泛型擦除是指在编译时，Java编译器会将泛型类型转换为原始类型（raw type），从而使得泛型信息在运行时不可用。这是为了保持向后兼容性，因为在Java 1.4之前没有泛型。
比如
```java
List<String> list = new ArrayList<>();
```
在编译时会被转换为
```java
List list = new ArrayList();
```

## 面向对象
### 面向对象的三大特性
1. 封装：将数据和操作数据的方法绑定在一起，隐藏内部实现细节，只暴露必要的接口
2. 继承：子类可以继承父类的属性和方法，实现代码复用和扩展
3. 多态：同一操作作用于不同的对象时，可以表现出不同的行为
### 面向对象设计原则
- 开闭原则
- 依赖倒置原则
- 单一职责原则
- 接口隔离原则
- 迪米特法则
- 里氏替换原则
- 合成复用原则