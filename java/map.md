# HashMap
## HashMap的底层原理
jdk1.8以前，hashmap是数组+链表的数据结构，jdk1.8以后，链表在长度大于8的时候转变为红黑树。  
红黑树是一种平衡二叉树，它保证了不会出现一条分支过长的情况，当插入一条数据后不符合红黑树的定义，就会进行旋转保证平衡。红黑树的查询速度很快
### 为什么不直接使用红黑树？
因为红黑树本身的旋转等操作会占用时间，长度不是很大的情况下数组+链表的效率反而更高

## HashMap的扩容机制
当HashMap中的元素数量超过了负载因子（默认0.75）时，HashMap会进行扩容。扩容的过程包括以下几个步骤：
1. 创建一个新的数组，大小是原数组的两倍。
2. 将原数组中的元素重新计算哈希值，并将它们放入新的数组中。
3. 更新HashMap的容量和负载因子。
4. 释放原数组的内存。
### 为什么容量总是2的幂次方？
因为HashMap使用哈希函数来计算元素的索引位置，使用2的幂次方可以使得哈希函数的计算更简单且分布更均匀。这样可以减少哈希冲突，提高查询效率。

## HashMap的put方法
put方法的主要步骤如下：
1. 调用object的hashcode方法，然后右移16位和原code进行异或，得到key的哈希值。
2. 根据哈希值找到对应的数组索引位置。
3. 如果该位置为空，则直接插入新元素。
4. 如果该位置已经有元素，则遍历链表或红黑树，检查是否存在相同的键。
5. 如果存在相同的键，则更新值；如果不存在，则将新元素添加到链表或红黑树的末尾。
6. 如果链表长度超过8，则将链表转换为红黑树。
7. 如果元素数量超过负载因子，则进行扩容。

## HasnMap的并发问题
#### 并发问题
1.多线程put操作可能导致数据丢失，当多个线程同时执行put操作时，可能会发生数据覆盖  
2.JDK1.7及之前，HashMap在扩容时可能形成环形链表，导致CPU 100%，JDK1.8已被修复
#### JDK1.8的解决方案
在JDK1.7中，HashMap扩容时使用头插法进行数据迁移，会导致扩容后链表顺序与原链表相反  
JDK1.8在数据迁移时使用尾插法，保持链表元素的原始顺序

## HashMap对比其他集合类
### HashMap vs Hashtable
1. HashMap是非线程安全的，而Hashtable是线程安全的。
2. HashMap允许null键和null值，而Hashtable不允许。
3. HashMap的性能通常优于Hashtable，因为Hashtable在每个方法上都进行了同步处理。
4. HashMap的迭代器是fail-fast的，而Hashtable的迭代器不是。
### HashMap vs LinkedHashMap
1. HashMap是无序的，而LinkedHashMap是有序的，按照插入顺序或访问顺序进行排序。
2. LinkedHashMap在遍历时可以保持元素的插入顺序，而HashMap不保证顺序。
3. LinkedHashMap的性能通常略低于HashMap，因为它需要维护一个双向链表来保持顺序。
### HashMap vs TreeMap
1. HashMap是基于哈希表实现的，而TreeMap是基于红黑树实现的。
2. HashMap的键值对是无序的，而TreeMap的键值对是有序的，按照键的自然顺序或指定的比较器顺序进行排序。
3. HashMap的性能通常优于TreeMap，因为TreeMap需要维护键的顺序。
4. TreeMap支持范围查询，而HashMap不支持。