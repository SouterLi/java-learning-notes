# HashMap
## HashMap的底层原理
jdk1.8以前，hashmap是数组+链表的数据结构，jdk1.8以后，链表在长度大于8的时候转变为红黑树。  
红黑树是一种平衡二叉树，它保证了不会出现一条分支过长的情况，当插入一条数据后不符合红黑树的定义，就会进行旋转保证平衡。红黑树的查询速度很快
### 为什么不直接使用红黑树？
因为红黑树本身的旋转等操作会占用时间，长度不是很大的情况下数组+链表的效率反而更高

## HashMap的扩容机制
当HashMap中的元素数量超过了负载因子（默认0.75）时，HashMap会进行扩容。扩容的过程包括以下几个步骤：
1. 创建一个新的数组，大小是原数组的两倍。
2. 将原数组中的元素重新计算哈希值，并将它们放入新的数组中。
3. 更新HashMap的容量和负载因子。
4. 释放原数组的内存。
### 为什么容量总是2的幂次方？
因为HashMap使用哈希函数来计算元素的索引位置，使用2的幂次方可以使得哈希函数的计算更简单且分布更均匀。这样可以减少哈希冲突，提高查询效率。

## HashMap的put方法
put方法的主要步骤如下：
1. 调用object的hashcode方法，然后右移16位和原code进行异或，得到key的哈希值。
2. 根据哈希值找到对应的数组索引位置。
3. 如果该位置为空，则直接插入新元素。
4. 如果该位置已经有元素，则遍历链表或红黑树，检查是否存在相同的键。
5. 如果存在相同的键，则更新值；如果不存在，则将新元素添加到链表或红黑树的末尾。
6. 如果链表长度超过8，则将链表转换为红黑树。
7. 如果元素数量超过负载因子，则进行扩容。

## HasnMap的并发问题
#### 并发问题
1.多线程put操作可能导致数据丢失，当多个线程同时执行put操作时，可能会发生数据覆盖  
2.JDK1.7及之前，HashMap在扩容时可能形成环形链表，导致CPU 100%，JDK1.8已被修复
#### JDK1.8的解决方案
在JDK1.7中，HashMap扩容时使用头插法进行数据迁移，会导致扩容后链表顺序与原链表相反  
JDK1.8在数据迁移时使用尾插法，保持链表元素的原始顺序

## HashMap对比其他集合类
### HashMap vs Hashtable
1. HashMap是非线程安全的，而Hashtable是线程安全的。
2. HashMap允许null键和null值，而Hashtable不允许。
3. HashMap的性能通常优于Hashtable，因为Hashtable在每个方法上都进行了同步处理。
4. HashMap的迭代器是fail-fast的，而Hashtable的迭代器不是。
### HashMap vs LinkedHashMap
1. HashMap是无序的，而LinkedHashMap是有序的，按照插入顺序或访问顺序进行排序。
2. LinkedHashMap在遍历时可以保持元素的插入顺序，而HashMap不保证顺序。
3. LinkedHashMap的性能通常略低于HashMap，因为它需要维护一个双向链表来保持顺序。
### HashMap vs TreeMap
1. HashMap是基于哈希表实现的，而TreeMap是基于红黑树实现的。
2. HashMap的键值对是无序的，而TreeMap的键值对是有序的，按照键的自然顺序或指定的比较器顺序进行排序。
3. HashMap的性能通常优于TreeMap，因为TreeMap需要维护键的顺序。
4. TreeMap支持范围查询，而HashMap不支持。


## ConcurrentHashMap
`ConcurrentHashMap`是Java提供的一个线程安全的哈希表实现，主要用于在多线程环境下高效且安全地存储和访问键值对。
### ConcurrentHashMap的底层原理
ConcurrentHashMap的底层结构和 HashMap 一样都是数组+链表（红黑树）的结构。  
ConcurrentHashMap使用CAS+synchronized的组合来保证线程安全。  
插入数据时，如果 hash 没有冲突，则直接使用 CAS 操作来插入数据；如果发生了 hash 冲突，则会使用 synchronized 锁住这个节点，然后进行后续操作。
### ConcurrentHashMap在jdk1.7和1.8的区别
1. **锁的粒度**：
    - JDK 1.7：使用分段锁（Segment Locking），将整个哈希表分为多个段（Segment），每个段有自己的锁，这样多个线程可以同时访问不同段的数据，提高并发性能。
    - JDK 1.8：取消了分段锁，改为使用更细粒度的锁（Node Level Locking），即对每个桶（Bucket）使用锁，这样进一步提高了并发性能。
2. **数据结构**：
    - JDK 1.7：底层数据结构是数组+链表，当链表长度超过一定阈值（默认8）时，会转换为红黑树，以提高查找效率。
    - JDK 1.8：底层数据结构仍然是数组+链表+红黑树，但在插入数据时，使用了 CAS 操作来减少锁的竞争。
3. **扩容机制**：
    - JDK 1.7：扩容时会锁住整个 Segment，其他线程无法访问该 Segment，可能导致性能瓶颈。
    - JDK 1.8：扩容时使用了更细粒度的锁，允许其他线程继续访问未被扩容的部分，提高了并发性能。
4. **性能**：
    - JDK 1.8 相比 JDK 1.7 在高并发场景下性能更好，尤其是在读多写少的场景下表现尤为突出。
