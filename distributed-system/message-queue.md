# 消息队列常见问题
## 2.消息队列的作用
解耦，系统A和很多系统都有关联，产生一条数据，只需要把数据放到mq里，别的系统谁需要使用，谁就订阅，不会和系统A直接产生关联；  
异步，主要是提升页面的响应速度，前端发起一个请求，系统A接受请求，需要把数据分别发送给BCD几个系统，使用mq，将消息发出去后直接返回前端，不需要等待BCD返回结果，加快的前端的响应速度；  
削峰，这个也比较好理解，瞬时突增的访问请求，我们先把请求放到mq里，再按照系统可以处理的速度分发请求，直到所有请求全部处理完成。
### 消息队列适合用在支付场景吗
不适合
因为使用消息队列不是实时的，我们日常使用支付都需要立马知道支付结果，如果使用mq，不知道什么时候才会把请求分发给服务端，在结果返回之前，使用者就需要一直等待，大大降低用户体验。

## 3.mq如何处理回滚？
- **1.重试机制**：当消费方处理消息出现异常返回处理失败时，mq 首先会进行重试，重新发送一条相同的消息，如果是临时的网络问题这种方式就可以解决；
- **2.死信队列**：当重试多次依然没有成功，那么这条消息就会进入死信队列，并通知管理员进行手动处理；
- **3.补偿事务**：当确定无法成功的时候，消费方会给生产方发一条逆操作的消息，生产方收到后会执行对应的逆操作，保证事务的一致性。

## 4.如何处理重复消费的问题？
消费方在接收到消息的时候，先通过**幂等性**判断此消息是否已经处理过，如果已经处理过了，就直接返回。
幂等性处理的方法有**业务状态检查**和**幂等令牌表**等。

## 5.消息队列如何保证一致性？
保证消息队列的一致性是一个系统性工程，需要生产方，消息队列，消费方三方协同共同实现一致性。 
### 1.保证生产方的一致性
保证生产方的业务逻辑和发送消息要么都成功要么都失败。
- **事务消息**：比如 RabbitMQ的两段提交机制。
生产者先把消息发送到 MQ，此时 MQ 不会发给消费者；
生产者执行本地数据库事务，如果成功给 MQ 发送 commit 指令，MQ 收到后消费方才会收到消息。
### 2.保证消息队列的消息不丢失
- **消息持久化**：MQ 会将消息持久化到磁盘，防止 Broker宕机导致消息丢失。
- **高可用架构**：MQ 的多副本机制保证即使部分节点宕机也可以正常提供服务。
- **确认机制**：生产者发送消息到 MQ，MQ 会向生产者发送 ACK 确认，生产者若没有收到 ACK 会进行重试；消费方消费消息成功会向 MQ发送 ACK，MQ 才会认为消息成功结束。
### 3.保证消费方的一致性
- **幂等性设计**：消费方接收到消息先对消息进行幂等性判断，如果已经消费过了，直接返回，防止重复消费。
- **重试与死信队列**：消费方消费消息失败时，向 MQ 返回一个NACK，MQ 会进行重试；重试有次数上限，超过上限还未成功，消息会进入死信队列，等待人工处理，防止阻塞其他正常消息。
