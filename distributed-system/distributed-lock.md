# 分布式锁

## 1.使用数据库
在数据库中建立一个保存锁信息的表，当线程需要获取锁时，尝试向该表中插入一条记录，如果插入成功，则表示获得锁；如果插入失败，则表示锁已被其他线程持有。
### 单点数据库问题如何解决？
两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。
### 如何给锁加失效时间？
做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
### 如何改为阻塞锁？
搞一个while循环，直到insert成功再返回成功。
### 如何将锁变成可重入的？
在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。

## 2.使用Redis
[Redis实现分布式锁](../database/redis/redis-distributed-lock.md)

## 3.使用zookeeper
### 1.获取锁  
首先，在Zookeeper当中创建一个持久节点ParentLock。
当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点 Lock1。
之后，Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。
如果是第一个节点，则成功获得锁。
这时候，如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。  
Client2查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是顺序最靠前的一个，结果发现节点Lock2并不是最小的。  
于是，Client2向排序仅比它靠前的节点Lock1注册Watcher，用于监听Lock1节点是否存在。这意味着Client2抢锁失败，进入了等待状态。  
这时候，如果又有一个客户端Client3前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock3。  
Client3查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock3是不是顺序最靠前的一个，结果同样发现节点Lock3并不是最小的。  
于是，Client3向排序仅比它靠前的节点Lock2注册Watcher，用于监听Lock2节点是否存在。这意味着Client3同样抢锁失败，进入了等待状态。  
这样一来，Client1得到了锁，Client2监听了Lock1，Client3监听了Lock2。这恰恰形成了一个等待队列，很像是Java当中ReentrantLock所依赖的AQS。  
### 2.释放锁  
释放锁分为两种情况：  
1.任务完成，客户端主动释放  
当任务完成时，Client1会显示调用删除节点Lock1的指令。  
2.任务执行过程中，客户端崩溃  
获得锁的Client1在任务执行过程中，如果崩溃，则会断开与Zookeeper服务端的链接。根据临时节点的特性，相关联的节点Lock1会随之自动删除。  
由于Client2一直监听着Lock1的存在状态，当Lock1节点被删除，Client2会立刻收到通知。
这时候Client2会再次查询ParentLock下面的所有节点，确认自己创建的节点Lock2是不是目前最小的节点。如果是最小，则Client2顺理成章获得了锁。
同理，如果Client2也因为任务完成或者节点崩溃而删除了节点Lock2，那么Client3就会接到通知。  
最终，Client3成功得到了锁。  
### 3.缺点：
性能上可能并没有缓存服务那么高。
因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。
ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。

