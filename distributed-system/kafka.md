# Kafka 常见面试问题
## 1.为什么kafka速度这么快?
1. 顺序 I/O 与持久化设计
- Kafka 将消息追加到日志文件末尾，利用磁盘顺序写入的特性（远快于随机写入）。
- Kafka 直接利用操作系统的页缓存（而非 JVM 堆内存），避免 GC 开销，同时依赖操作系统异步刷盘策略，减少磁盘 I/O 阻塞。
2. 零拷贝技术
- 传统数据读取需要经过 磁盘 → 内核缓冲区 → 用户缓冲区 → Socket 缓冲区 → 网卡，而 Kafka 通过 sendfile() 系统调用，直接将数据从页缓存发送到网卡（跳过用户空间复制），大幅降低 CPU 和内存开销。
3. 分区（Partition）与并行化
- 水平扩展能力：Topic 划分为多个 Partition，分散到不同 Broker 节点，实现读写负载均衡。
- 并行生产与消费：Producer 和 Consumer 可同时操作多个 Partition，充分利用集群资源。
4. 批处理与压缩
- Producer 累积消息后批量发送，Consumer 一次拉取多个消息，减少网络和 I/O 开销。
- 端到端压缩，减少网络传输数据量。

## 2.你们的项目中Kafka主要传递哪些消息？
我们的系统中Kafka主要用于传递业务流转消息，比如服务A完成了自己的事情，就发一条消息到Kafka，通知服务B可以开始处理了。

## 3.Kafka的队列模型是什么？
发布订阅模型 
使用Topic作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。
在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。

## 如何理解Kafka中的Broker，Partition，Replica？
Broker（代理）: 可以看作是一个独立的 Kafka 实例。类似于“服务器”的角色。  
Partition（分区）: Partition是Topic的物理分组，每个Topic可划分为多个有序的Partition，类似于“分片”概念。同一个Topic的消息会随机发送到不同的Partition，用来并行处理，提升消息的吞吐量。 同一个Partition内部的消息是有序的。  
Replica（副本）：Replica是Partition的冗余备份，用于实现高可用。   

## 5.Kafka的多副本机制，有什么好处？
Kafka 为分区（Partition）引入了多副本（Replica）机制。
分区（Partition）中的多个副本之间会有一个 leader ，其他副本称为 follower。
我们发送的消息会被发送到 leader ，然后 follower 才能从 leader 中拉取消息进行同步。
生产者和消费者只与 leader 交互。
你可以理解为其他副本只是 leader 的拷贝，它们的存在只是为了保证消息存储的安全性。
当 leader 发生故障时会从 follower 中选举出一个 leader，但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。
多副本机制极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。

## 6.如何保证 Kafka 中消息消费的顺序？
生产者：确保消息按顺序写入分区，且将需要保序的消息发送到同一个分区。具体方法就是给一组消息指定相同的 Key，Kafka 默认的分区器会根据 Key 的哈希值将其映射到特定的分区。  
消费者：采用单线程模型消费该分区。  

## 7.kafka如何保证消息不丢失？
### 1.生产者发送不丢失  
设置ack=all，当所有的broker全部收到消息后，再返回成功；  
如果返回失败，进行重试；  
如果重试失败，将消息持久化，等待服务恢复，再进行发送。  
### 2.服务器保存消息不丢失  
当ISR中所有的副本全部宕机时，kafka重新选举的leader没有最新的消息，这条消息就会丢失，
我们可以设置unclean.leader.election.enable=false，不在ISR中的副本不可参与竞选leader，此时服务会进入不可用状态，但消息不回丢失。  
### 3.消费者消费不丢失  
将自动提交enable.auto.commit设置为false，消费者手动控制提交的逻辑，可以保证消息不丢失