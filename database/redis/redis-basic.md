# Redis基础知识

## Redis的数据结构
### String
字符串类型，实现方式是简单动态字符串。  
**简单动态字符串**：由三部分组成，len记录字符串的长度，buf[]指向实际存储字符串的内存地址，free指向剩余的内存空间。
### Hash
Hash类型，类似于Java中的Map，存储键值对。  
当数据量较少时，使用ziplist实现；当数据量较大时，使用hashtable实现。  
**ziplist**：是一种压缩列表，字段和值交替排列，使用连续的内存空间存储键值对。
### List
列表类型，类似于Java中的List，存储有序的字符串。实现原理是双向链表。
### Set
集合类型，类似于Java中的Set，无序，不可重复。
### SortedSet / ZSet
类似Set，但是有序。  
使用hashMap和跳表保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score。

## Redis持久化机制
### RDB
RDB是Redis默认的持久化方式。  
指定时间间隔内将内存中的全量数据生成快照并保存到二进制文件(默认为dump.rdb)。
#### 优点
- 快照文件小，加载和恢复数据速度快。
#### 缺点
- 可能丢失最后一次快照后的数据。
- 持久化有延迟。
### AOF
将每次写操作以追加的形式记录到日志文件中，默认文件名为appendonly.aof。
#### 优点
- 数据安全性高(最多丢失1秒数据)
- AOF文件易于理解和解析
#### 缺点
- 文件较大，恢复速度慢。
- 频繁写入可能影响性能。

## 缓存穿透、雪崩、击穿
### 缓存穿透
缓存穿透是指查询一个根本不存在的数据，导致请求直接落到数据库上，可能引发数据库压力过大甚至宕机。  
   **典型场景**： 恶意攻击：故意查询不存在的ID；业务误操作：查询已下架商品或已注销用户  
   **解决方案**： 布隆过滤器（Bloom Filter）
### 缓存雪崩
   大量缓存同时失效或缓存服务宕机，导致所有请求直接访问数据库，造成数据库压力激增。  
   **典型场景**：缓存服务器重启；相同过期时间的大批量缓存  
   **解决方案**：差异化过期时间
### 缓存击穿
   某个热点key失效的瞬间，大量并发请求直接访问数据库，导致数据库压力骤增。  
   **解决方案**：互斥锁（Mutex Lock）
## 布隆过滤器
布隆过滤器是一种空间效率高的概率型数据结构，用于快速判断一个元素是否在一个集合中。
- **特点**：可能返回存在但实际上不存在，但返回不存在就一定不存在。效率很高，空间占用小。
- **原理**：使用多个哈希函数将元素映射到一个位数组中，当查询时，检查对应的位是否为1。如果所有对应位都为1，则认为元素可能存在；如果有任意一位为0，则认为元素一定不存在。
- **应用场景**：缓存穿透、去重、大数据查询等。

## Redis的应用场景
- **缓存**： 缓存热点数据，全页缓存，对象缓存
- **消息队列**
- **分布式锁**： [Redis实现分布式锁](redis-distributed-lock.md)
- **限流**

## Redis和数据库如何保持一致性？
当需要进行数据更新的时候，先更新数据库，再删除缓存。