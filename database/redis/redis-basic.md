# Redis基础知识

## Redis的数据结构
### String
字符串类型，实现方式是简单动态字符串。  
**简单动态字符串**：由三部分组成，len记录字符串的长度，buf[]指向实际存储字符串的内存地址，free指向剩余的内存空间。
### Hash
Hash类型，类似于Java中的Map，存储键值对。  
当数据量较少时，使用ziplist实现；当数据量较大时，使用hashtable实现。  
**ziplist**：是一种压缩列表，字段和值交替排列，使用连续的内存空间存储键值对。
### List
列表类型，类似于Java中的List，存储有序的字符串。实现原理是双向链表。
### Set
集合类型，类似于Java中的Set，无序，不可重复。
### SortedSet / ZSet
类似Set，但是有序。  
使用hashMap和跳表保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score。

## Redis为什么这么快？
### 内存存储
Redis将数据存储在内存中，读写速度极快。
### 单线程模型
Redis采用单线程模型，避免了多线程的上下文切换和锁竞争问题。
### 事件驱动
Redis使用事件驱动模型，使用I/O多路复用技术，能够高效地处理大量并发连接。
### 数据结构优化
Redis使用高效的数据结构，如跳表、哈希表等，优化了数据的存储和访问效率。

## Redis持久化机制
### RDB
RDB是Redis默认的持久化方式。  
指定时间间隔内将内存中的全量数据生成快照并保存到二进制文件(默认为dump.rdb)。
#### 优点
- 快照文件小，加载和恢复数据速度快。
#### 缺点
- 可能丢失最后一次快照后的数据。
- 持久化有延迟。
### AOF
将每次写操作以追加的形式记录到日志文件中，默认文件名为appendonly.aof。
#### 优点
- 数据安全性高(最多丢失1秒数据)
- AOF文件易于理解和解析
#### 缺点
- 文件较大，恢复速度慢。
- 频繁写入可能影响性能。

## 缓存穿透、雪崩、击穿
### 缓存穿透
缓存穿透是指查询一个根本不存在的数据，导致请求直接落到数据库上，可能引发数据库压力过大甚至宕机。  
   **典型场景**： 恶意攻击：故意查询不存在的ID；业务误操作：查询已下架商品或已注销用户  
   **解决方案**： 布隆过滤器（Bloom Filter）
### 缓存雪崩
   大量缓存同时失效或缓存服务宕机，导致所有请求直接访问数据库，造成数据库压力激增。  
   **典型场景**：缓存服务器重启；相同过期时间的大批量缓存  
   **解决方案**：差异化过期时间
### 缓存击穿
   某个热点key失效的瞬间，大量并发请求直接访问数据库，导致数据库压力骤增。  
   **解决方案**：互斥锁（Mutex Lock）

## Redis的应用场景
### 缓存
- 缓存热点数据
- 全页缓存
- 对象缓存
### 消息队列
### 分布式锁
### 限流

## Redis和数据库如何保持一致性？
当需要进行数据更新的时候，先更新数据库，再删除缓存。