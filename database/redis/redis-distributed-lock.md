# Redis实现分布式锁

## 单机情况下的加解锁
使用Redis的`SETNX`命令加锁，并设置一个过期时间，防止死锁。  
使用`DEL`配合LUA脚本释放锁。因为删除之前先判断key是否是当前线程持有的锁，如果是再进行删除防止误删，这是两个操作，LUA脚本可以保证原子性。

### 如果超过了Redis的过期时间线程还没有结束，要怎么处理？
自动续期，如果线程还在运行，定时任务每隔一段时间(如500ms)去续期锁，直到线程结束。

## 分布式情况下的加解锁
使用RedLock算法来实现分布式锁。RedLock算法的核心思想是使用多个独立的Redis实例来实现锁的可靠性。
### RedLock算法的步骤
1. 获取当前时间‌：客户端记录获取锁开始时的Unix时间戳
2. 依次尝试加锁‌：向所有N个节点发送加锁命令
3. 如果成功获取锁的实例数大于等于`N/2 + 1`(N为Redis实例数)，则认为锁获取成功。
4. 如果获取锁成功，则在每个实例上设置一个过期时间，防止死锁。
5. 在使用完锁后，释放锁时需要在每个Redis实例上执行`DEL`命令，并确保只删除当前线程持有的锁。

### Redisson
Redisson是一个基于RedLock算法的Java客户端，提供了分布式锁的实现，建议在实际生产环境中使用Redisson来实现分布式锁。
- 使用Redisson可以简化分布式锁的实现，提供了更高层次的API。
- Redisson提供了多种锁的实现，如公平锁、可重入锁、读写锁等。
- Redisson还提供了分布式锁的实现，方便在分布式环境中使用。
- Redisson支持自动续期、锁过期等功能，避免了手动处理锁的复杂性。