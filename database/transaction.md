#  数据库事务
## 事务的四大特性
#### 原子性
原子性就是指一个事务，要么都执行，要么都不执行。
串行条件下，事务的原子性主要表现在，一旦事务执行过程中出现报错，则所有的操作都要被回滚。
#### 持久性
已经执行的操作，可以持久的保存在磁盘中，不会因为服务宕机而导致数据丢失。
要实现这个特性，需要借助mysql中的redolog，redolog中保存的是物理操作，即为sql操作结束后数据库最终的结果，物理保存在redolog中
sql执行过程必须将redolog写入到磁盘后，事务才会提交。
当服务宕机时，部分数据可能还没来得及写回磁盘，重启后，就会去读取redolog，进行数据恢复，保证事务的操作会全部写回磁盘，保证持久性
#### 隔离性
隔离性就是指多个事务并行执行，且相互影响的情况下，如何保证各自事务执行结果的正确性。
实际情况下，我们很难保证多个事务并行执行，还可以保证完全的隔离性，虽然单个事务看没有问题，但是从总体看就会造成一致性的问题，串行执行虽然可以保证隔离性，但是会影响事务执行的效率。根据数据一致性的要求不同，对sql执行效率的要求不同，就出现了几种不同的事务隔离级别。
#### 一致性
是指一个事务的多次操作，产生的中间状态对其他事务不可见，其他事务只能看到这个事务的开始状态的最后的结束状态。
### 事务的实现机制
#### 1.原子性实现
- Undo Log：记录事务发生前的数据状态，回滚时执行逆向操作
#### 2.持久性实现
- Redo Log：记录事务对数据页的物理修改
- WAL(Write-Ahead Logging)机制：先写日志再修改数据
#### 3.隔离性实现
- 锁机制： 共享锁(S锁)/排他锁(X锁)，意向锁(IS/IX)，间隙锁(Gap Lock)
- MVCC： 通过版本链实现非锁定读，ReadView机制控制可见性
#### 4.一致性实现
- 由其他三个特性共同保证
- 数据库完整性约束(主键、外键等)

## MySQL如何解决幻读问题
在快照读的情况下， 使用MVCC防止幻读；
在当前读情况下，使用行锁和间隙锁防止幻读。

## MVCC
### 1.什么是MVCC？
MVCC全称多版本并发控制。是一种并发控制的方法。在数据库访问中实现数据库的并发访问，在编程领域实现事务内存。
MVCC在mysql中主要的作用是提高并发访问数据库的性能，用更好的方法处理读写并发的情况，做到即使有读写冲突的时候，也不需要加锁，非阻塞的并发读。
### 2.MVCC和快照读的关系
MVCC本质上是一种思想，快照读就是在mysql中MVCC的一种实现方式。
快照读实际上也是一种概念，再具体一些，mysql是通过在行中间增加了3个辅助字段，undolog，Read View一起实现了快照读的功能。
快照读
一条数据有多个版本，读取的不一定是最新的版本，可以根据需要进行选择。
在mysql中，select语句就是使用的快照读。
当前读
每次读取总是读取数据库中最新的数据，实现当前读需要对数据库加锁，保证读取的时候不被其他事务修改。
在mysql中，update，insert，delete，select...for update，select lock in share mode都是当前读。
### 3.MVCC的实现原理
MYsql中实现MVCC，是通过3个辅助字段，undolog和ReadView共同实现的。
3个辅助字段
DB_TRX_ID：最近修改事务ID
DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本
DB_ROW_ID：隐藏主键，自增ID，如果表没有主键，就会自动用这个字段建立聚簇索引
undo log
分为insert undo log和update undo log
insert undo log在新增数据的时候生成，只用于事务回滚，如果事务成功提交，就可以立即丢弃；
update undo log在更新数据的时候生成，用于事务回滚和快照读，多次更新一条数据，会生成一个undo log的更改链，下一次更改会保存上一次更改的指针，当前的数据会保存undo log中最新的一次更改的指针。
Read View
当开启一次快照读时，会生成一个Read View，内容就是当前数据库的一个快照。这个快照不一定是数据库中最新的数据，也有可能是undo log中的数据，这个要遵循一个可见性算法。

## 事务的隔离级别
#### 1.READ UNCOMMITED
此隔离级别没有做任何处理，因此可能会出现脏读，不可重复读和幻读
使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）
#### 2.READ COMMITED
读已提交，此时读的时候是快照读，读的时候读的并不是此时数据库的数据，而是会生成一个ReadView，ReadView中存储的是最近一次commit的数据，读取的是ReadView里的数据，如果一个事务A有多次读数据库，这中间别的事务B有修改值并提交，那么事务A第一次读取的是快照1，事务A第二次读取的就是快照2
只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）
#### 3.REPEATABLE READ
可重复读，原理和READ COMMITED类似，不过生成快照的方式不太一样，可重复读的隔离级别下， 事务A多次读取数据都只会生成一次ReadView，后续的读取都读取的是第一次生成的Read View，所以无论中间别的事务是否会提交，都不会改变事务A读取数据的结果。因此不会出现多次读取不一致的情况。
#### 4.SERIALIZABLE
串行，读数据时加锁，其他事务阻塞。

## 事务的传播方式
#### REQUIRED
默认的传播方式，方法必须运行在事务中，如果已经有事务，就在这个事务中运行，如果没有事务，就新创建一个事务。
#### REQUIRES_NEW
无论是否已经有事务，都会新创建一个事务
#### NESTED
如果已经有事务，该方法会在嵌套事务中运行，如果没有事务，就新建一个事务
#### SUPPORTS
本身不需要事务，如果有事务，就在这个事务中运行，如果没有事务，就不在事务中运行
#### NOT_SUPPORTED
该方法不应该在事务中运行，如果已经有事务，就将方法挂起
#### NEVER
不支持事务，如果有事务，就抛出异常
#### MANDATORY
不支持事务，如果有事务，就抛出异常IllegalTransactionStateException
## 共享锁和排他锁
#### 共享锁（S锁/读锁）
- 特性：允许多个事务同时读取数据，但阻止其他事务获取排他锁
- 使用场景：读取数据时使用，确保数据在读取过程中不被修改
- 兼容性：与其它共享锁兼容，与排他锁不兼容
#### 排他锁（X锁/写锁）
- 特性：独占锁，阻止其他事务获取任何类型的锁（包括共享锁和排他锁）
- 使用场景：插入、更新或删除数据时使用
- 兼容性：与任何锁都不兼容
#### 意向锁
  意向锁是表锁，表示即将对某些行加锁
  当一个事务要对某些行加锁之前，会先对这张表加一个意向锁，作用就是提高锁冲突检测的效率。
  没有意向锁时，事务B想加表锁，它就需要全表扫描是否有行锁；如果有意向锁，事务B只需要检查是否有意向锁，立即就可以知道自己是否可以加锁了。
  另一个作用就是意向锁实现了表锁和行锁的共存。
  自动加锁：InnoDB自动管理意向锁，开发者无需显式操作
  与隔离级别关系：意向锁在所有隔离级别下都存在
  

## Transactional注解
### Transactional 使用注意事项
1.Transactional可以被用于类和方法，接口和接口方法，注意，当用于方法时，只有public方法事务才会被启用；当用于其他方法时，也不会报错，只是不会生效  
2.仅仅加上@Transactional是不会开启事务的，需要在配置文件中使用配置元素，才会开启事务  
3.通过配置元素的proxy-target-class，用来控制使用jdk的代理还是使用cglib代理，如果设置为true，就使用cglib，如果设置为false或者不设置，就会忽略cglib，转而使用jdk代理  
4.建议直接在实现类上或方法上使用transactional，尽量不要在接口上使用。在接口上使用Transactional，只有设置了基于接口的代理才会生效，  
### Transactional 原理
transactional基于AOP，AOP基于JDK的动态代理机制。  
Springboot自动支持事务，无需手动配置  
Spring boot启动时，由于自动装配，会生成一个AOP切面类TransactionInterceptor。所有符合AOP规则要求的类或者方法都会进入这个切面类。  
AOP容器为使用了@Transactional注解的类创建代理，执行代理类的目标方法时，会调用Advisor类的getAdvise方法，获取TransactionInterceptor，并执行invoke方法。  
invoke方法会调用invokeWithinTransaction方法，在invokeWithinTransaction方法中，完整地实现了事务管理的功能。  
