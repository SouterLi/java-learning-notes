# MySQL常见问题

## 1.MySQL里常见的锁有哪些？
### 共享锁（S锁/读锁）
- 特性：行级锁，允许多个事务同时读取数据，但阻止其他事务获取排他锁
- 使用场景：读取数据时使用，确保数据在读取过程中不被修改，可以使用SELECT ... LOCK IN SHARE MODE语句显式加共享锁
- 兼容性：与其它共享锁兼容，与排他锁不兼容
### 排他锁（X锁/写锁）
- 特性：也是行级锁，独占锁，阻止其他事务获取任何类型的锁（包括共享锁和排他锁）
- 使用场景：插入、更新或删除数据时InnoDB会自动为涉及的行加排他锁，如果希望在读数据的时候加排他锁，需要使用SELECT ... FOR UPDATE语句显式加排他锁
- 兼容性：与任何锁都不兼容
### 意向锁
意向锁是表锁，表示即将对某些行加锁。  
当一个事务要对某些行加锁之前，会先对这张表加一个意向锁，作用就是提高锁冲突检测的效率。  
没有意向锁时，事务B想加表锁，它就需要全表扫描是否有行锁；如果有意向锁，事务B只需要检查是否有意向锁，立即就可以知道自己是否可以加锁了。  
另一个作用就是意向锁实现了表锁和行锁的共存。  
自动加锁：InnoDB自动管理意向锁，开发者无需显式操作  
与隔离级别关系：意向锁在所有隔离级别下都存在
### 间隙锁（Gap Lock）
- 特性：行锁的一种，锁定索引范围内的间隙
- 使用场景：防止幻读，确保在当前事务中，其他事务不能在锁定范围内插入新行
- 兼容性：与共享锁兼容，与排他锁不兼容
- 注意：间隙锁只在REPEATABLE READ和SERIALIZABLE隔离级别下使用，防止幻读

## 2.MySQL 是如何避免幻读的？
MySQL 通过使用锁机制来避免幻读。
在可重复读隔离级别下，MySQL 使用间隙锁（Gap Lock）来锁定范围内的记录，从而防止其他事务在该范围内插入新记录。
这样可以确保在一个事务中多次读取同一范围时，结果是一致的，不会出现幻读现象。

## 3.你知道数据库事务吗，一般是怎么使用事务的？
数据库事务是指一组操作的集合，这些操作要么全部成功，要么全部失败，保证数据的一致性和完整性。事务具有四个基本特性，简称为 ACID：
1. **原子性（Atomicity）**：事务中的所有操作要么全部成功，要么全部失败。
2. **一致性（Consistency）**：事务执行前后，数据库都处于一致的状态。
3. **隔离性（Isolation）**：不同事务之间相互隔离，互不干扰。
4. **持久性（Durability）**：一旦事务提交，数据的修改是永久性的，即使系统崩溃也不会丢失。

我一般使用 Transactional 注解来管理事务。
在方法上添加 @Transactional 注解，表示该方法需要在事务中执行。
Spring 会自动处理事务的开始、提交和回滚。

## 4.Transactional注解有失效的时候吗？如果有，是什么情况？
@Transactional 注解在以下情况下可能会失效：
1. **内部方法调用**：如果在同一个类中调用带有 `@Transactional` 注解的方法，Spring 不会拦截这个调用，因此事务不会生效。解决方法是将该方法提取到另一个类中，或者使用 AOP 代理。
2. **非 public 方法**：`@Transactional` 注解只对 public 方法有效。如果在类中使用了 `@Transactional` 注解，但方法是 private、protected 或 package-private，则事务不会生效。
3. **异常类型**：默认情况下，`@Transactional` 只会对`RuntimeException`和`Error`进行回滚。如果抛出的是受检异常（`Checked Exception`），则不会回滚事务。可以通过设置 `rollbackFor` 属性来指定需要回滚的异常类型。
4. **事务传播行为**：如果在同一个事务中调用了另一个事务方法，并且传播行为设置为 `REQUIRES_NEW`，则会创建一个新的事务，这可能导致原有事务失效。
5. **数据库引擎不支持事务**：如果使用了不支持事务的数据库引擎（如 MyISAM），则 `@Transactional` 注解不会生效。
6. **AOP 代理问题**：如果使用了 CGLIB 代理且注解放在了接口类而不是实现类，会导致事务失效。
7. **多线程环境**：在多线程环境中，如果事务方法被多个线程并发调用，可能会导致事务失效。因为每个线程都有自己的事务上下文，无法共享事务状态。
