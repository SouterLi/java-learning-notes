# 高性能查询详解

## 1.如何做sql性能优化？
1. **索引优化**：
    - 确保查询条件列有索引，优先使用联合索引，并遵循最左前缀原则。
    - 覆盖索引：索引的列包含了所有要返回的列，查询仅通过索引就能获取需要的数据，避免回表。
    - 定期检查并删除未使用的索引。
2. **SQL语句优化**：
    - 避免使用 `SELECT *`，只查询需要的列。
    - 确保 `JOIN` 字段有索引，且小表在左边。
    - 避免隐式类型转换，确保查询条件类型一致。
3. **数据库设计优化**：
    - 适当冗余数据，减少 `JOIN` 操作。
    - 使用分库分表策略，降低单表数据量。
4. **缓存策略**：
    - 使用 Redis 等缓存热点数据，减少数据库压力。
### 什么是最左前缀原则
假设有一个联合索引 (A, B, C)，那么最左前缀原则要求查询条件中必须包含索引的最左边的列 A，才能使用该索引。如果查询条件中只包含 B 或 C，或者包含 B 和 C，但不包含 A，那么该索引将无法被使用。  
最左前缀原则的作用是确保索引的有效性和查询性能。

## 2.sql优化后性能提升了多少？你是怎么测量和判断性能提升了百分之多少？
top sql 性能提升最高超过 10倍，平均可以提升 100% 以上。
1. **执行计划对比**：使用 `EXPLAIN` 命令查看优化前后的执行计划，分析查询的成本和步骤。
2. **响应时间对比**：在相同数据量和负载下，记录查询的响应时间，比较优化前后的差异。
3. **日志分析**：通过分析数据库日志，查看查询的执行时间和频率，评估优化效果。
   根据上述数据，计算性能提升的百分比。

## 3. 如何解读执行计划？
1. **type**：表示连接类型，常见的有 `ALL`（全表扫描）、`index`（索引扫描）、`range`（范围扫描）、`ref`（非唯一索引扫描）、`eq_ref`（唯一索引扫描）、`const`（常量表）等。连接类型越靠后，性能越好。
2. **possible_keys**：表示查询中可能使用的索引。
3. **key**：表示实际使用的索引。
4. **rows**：表示估算需要扫描的行数，行数越少，性能越好。
5. **Extra**：表示额外信息，如 `Using index`（使用覆盖索引）、`Using where`（使用了 WHERE 条件）、`Using temporary`（使用了临时表）、`Using filesort`（使用了文件排序）等。`Using index` 是最理想的，`Using temporary` 和 `Using filesort` 通常表示性能较差。

## 3.如果SQL走了索引依然很慢，可能是什么原因？
1. 数据量过大
2. 索引选择不当，索引列区分度不足
3. 锁竞争或者事务阻塞，导致查询延迟
4. 服务器资源瓶颈，如CPU、内存、磁盘I/O等

## 4.索引在哪些情况下会失效？
- 条件列使用函数
- 条件列隐式类型转换
- 条件列使用了不等于（<>）、IS NULL、LIKE '%xxx'等操作
- 条件列没有使用最左前缀
- OR 连接多个条件时，前面的条件没有使用索引
- 复合索引没有遵循最左前缀原则
- 数据分布不均匀，导致索引选择不当

## 5.分库分表
### 1.水平分表
将一张大表的数据，水平拆分成几张表，让每张表的数据量变小；  
水平分表是为了解决单表数据量过大导致查询性能变差的问题。  
### 2.垂直分表
将一张表的不同字段拆分到多张表，让每张表的字段数量变少；  
垂直分表是为了处理表字段过多导致聚簇索引查询效率降低的问题。  
一种做法是将常用的字段放到一张表中，不常用的字段放到另一张表中，减少每次查询的结果长度，这样可以充分提升热点数据的查询效率；  
另外就是将大数据放到一张表，较短的数据放到一张表。这样也是为了减少每次查询的长度。  
#### 为什么要减少查询结果的长度？
1.本身数据量大需要更长的读取时间；  
2.跨页，页是数据的存储单位，查找和定位操作都是以页为单位，相同大小的页，可以保存更多的行数数据库整体性能越好；  
3.数据库以行为单位缓存到内存中，每行数据越小，缓存的行数越多，命中率越高，效率也就越高。  
### 如何处理分页查询
#### 1.全局视野法
将所有数据库中前三页的数据都查出来，统一进行排序  
优点是结果精确，缺点是效率很差，且页数越高效率越差，因为要把前N页的都查出来，再进行所有数据库的排序  
#### 2.业务折衷-禁止跳页查询
增加一个条件，前端不支持跳页，每次只能查看下一页。  
举例每页10条，取到当前页的最大id：A，去每个库中查询id>A，查10条，再将所有结果排序取10条，返回前端  
优点：结果精确，效率很好，写法简单。  
缺点：禁止跳页  
#### 3.二次查询法
两个表，分页查询，按照日期date排序，每页5条，查询第101页，偏移量为500。  
首次查询，去每个表中查询前505条（偏移量+每页大小）数据，只查排序字段date，这个字段设计的时候就必须加索引，所以下面这个sql效率是非常高的。  
select date from table1 order by date limit 505;  
select date from table2 order by date limit 505;  
从1010条结果中取第501条date，获得边界值date1;  
第二次查询  
select * from table1 where date >= date1 order by date limit 5;  
select * from table2 where date >= date1 order by date limit 5;  
将10条结果排序，取前5条，就是最终结果了。  
### 分库如何扩容
#### 1.停服迁移
停服，使用数据迁移工具完成迁移，修改入库规则，重启服务
#### 2.从库迁移
比如有两台数据库，分别有两个从库，一共四个，其中A和A0数据一致，B和B0数据一致；  
主库不变，直接修改分片规则，将原本%2=0放入A库改为%4=0放入A库，%4=2放入A0库；B库以此类推；  
然后将A库中%4=2的数据清理掉，其他3个库以此类推将废弃数据清理掉，完成扩容。  
最后再抽时间给每个数据库搭配一个从库。  
这种方式的优点是无需停止服务进行升级和迁移。  
#### 3.双写迁移
倍数扩容  
向老库和新库同时写入数据，同时将历史数据进行迁移；  
迁移完成，修改分片规则；  
最后清理废弃数据。  

## 6.MySQL使用InnoDB查询就一定不用回表吗
不是的。如果你使用的查询条件是二级索引，那么第一步会根据二级索引查询对应的主键ID，然后进行回表，根据主键ID查询聚簇索引，才可以查到数据。
