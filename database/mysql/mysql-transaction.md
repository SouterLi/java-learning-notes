#  数据库事务
## 事务的四大特性
#### 原子性
原子性就是指一个事务，要么都执行，要么都不执行。
串行条件下，事务的原子性主要表现在，一旦事务执行过程中出现报错，则所有的操作都要被回滚。
#### 持久性
已经执行的操作，可以持久的保存在磁盘中，不会因为服务宕机而导致数据丢失。
要实现这个特性，需要借助mysql中的redolog，redolog中保存的是物理操作，即为sql操作结束后数据库最终的结果，物理保存在redolog中
sql执行过程必须将redolog写入到磁盘后，事务才会提交。
当服务宕机时，部分数据可能还没来得及写回磁盘，重启后，就会去读取redolog，进行数据恢复，保证事务的操作会全部写回磁盘，保证持久性
#### 隔离性
隔离性就是指多个事务并行执行，且相互影响的情况下，如何保证各自事务执行结果的正确性。
实际情况下，我们很难保证多个事务并行执行，还可以保证完全的隔离性，虽然单个事务看没有问题，但是从总体看就会造成一致性的问题，串行执行虽然可以保证隔离性，但是会影响事务执行的效率。根据数据一致性的要求不同，对sql执行效率的要求不同，就出现了几种不同的事务隔离级别。
#### 一致性
是指一个事务的多次操作，产生的中间状态对其他事务不可见，其他事务只能看到这个事务的开始状态的最后的结束状态。
## 事务的实现机制
#### 1.原子性实现
- Undo Log：记录事务发生前的数据状态，回滚时执行逆向操作
#### 2.持久性实现
- Redo Log：记录事务对数据页的物理修改
- WAL(Write-Ahead Logging)机制：先写日志再修改数据
#### 3.隔离性实现
- 锁机制： 共享锁(S锁)/排他锁(X锁)，意向锁(IS/IX)，间隙锁(Gap Lock)
- MVCC： 通过版本链实现非锁定读，ReadView机制控制可见性
#### 4.一致性实现
- 由其他三个特性共同保证
- 数据库完整性约束(主键、外键等)

## MySQL如何解决幻读问题
在快照读的情况下， 使用MVCC防止幻读；
在当前读情况下，使用行锁和间隙锁防止幻读。

## MVCC
### 1.什么是MVCC？
MVCC全称多版本并发控制。是一种并发控制的方法。在数据库访问中实现数据库的并发访问，在编程领域实现事务内存。
MVCC在mysql中主要的作用是提高并发访问数据库的性能，用更好的方法处理读写并发的情况，做到即使有读写冲突的时候，也不需要加锁，非阻塞的并发读。
### 2.MVCC和快照读的关系
MVCC本质上是一种思想，快照读就是在mysql中MVCC的一种实现方式。
快照读实际上也是一种概念，再具体一些，mysql是通过在行中间增加了3个辅助字段，undolog，Read View一起实现了快照读的功能。  
**快照读**  
一条数据有多个版本，读取的不一定是最新的版本，可以根据需要进行选择。  
在mysql中，select语句就是使用的快照读。  
**当前读**  
每次读取总是读取数据库中最新的数据，实现当前读需要对数据库加锁，保证读取的时候不被其他事务修改。  
在mysql中，update，insert，delete，select...for update，select lock in share mode都是当前读。  
### 3.MVCC的实现原理
MYsql中实现MVCC，是通过3个辅助字段，undolog和ReadView共同实现的。  
- 3个辅助字段  
  - DB_TRX_ID：最近修改事务ID  
  - DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本  
  - DB_ROW_ID：隐藏主键，自增ID，如果表没有主键，就会自动用这个字段建立聚簇索引  
- undo log  
  分为insert undo log和update undo log  
  insert undo log在新增数据的时候生成，只用于事务回滚，如果事务成功提交，就可以立即丢弃；  
  update undo log在更新数据的时候生成，用于事务回滚和快照读，多次更新一条数据，会生成一个undo log的更改链，下一次更改会保存上一次更改的指针，当前的数据会保存undo log中最新的一次更改的指针。
- Read View  
  当开启一次快照读时，会生成一个Read View，内容就是当前数据库的一个快照。这个快照不一定是数据库中最新的数据，也有可能是undo log中的数据，这个要遵循一个可见性算法。

## 事务的隔离级别
#### 1.READ UNCOMMITED
此隔离级别没有做任何处理，因此可能会出现脏读，不可重复读和幻读
使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）
#### 2.READ COMMITED
读已提交，此时读的时候是快照读，读的时候读的并不是此时数据库的数据，而是会生成一个ReadView，ReadView中存储的是最近一次commit的数据，读取的是ReadView里的数据，如果一个事务A有多次读数据库，这中间别的事务B有修改值并提交，那么事务A第一次读取的是快照1，事务A第二次读取的就是快照2  
只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）
#### 3.REPEATABLE READ
可重复读，原理和READ COMMITED类似，不过生成快照的方式不太一样，可重复读的隔离级别下， 事务A多次读取数据都只会生成一次ReadView，后续的读取都读取的是第一次生成的Read View，所以无论中间别的事务是否会提交，都不会改变事务A读取数据的结果。因此不会出现多次读取不一致的情况。
#### 4.SERIALIZABLE
串行，读数据时加锁，其他事务阻塞。

## 事务的传播方式
#### REQUIRED
默认的传播方式，方法必须运行在事务中，如果已经有事务，就在这个事务中运行，如果没有事务，就新创建一个事务。
#### REQUIRES_NEW
无论是否已经有事务，都会新创建一个事务
#### NESTED
如果已经有事务，该方法会在嵌套事务中运行，如果没有事务，就新建一个事务
#### SUPPORTS
本身不需要事务，如果有事务，就在这个事务中运行，如果没有事务，就不在事务中运行
#### NOT_SUPPORTED
该方法不应该在事务中运行，如果已经有事务，就将方法挂起
#### NEVER
不支持事务，如果有事务，就抛出异常
#### MANDATORY
不支持事务，如果有事务，就抛出异常IllegalTransactionStateException

## MySQL里常见的锁有哪些？
### 共享锁（S锁/读锁）
- 特性：行级锁，允许多个事务同时读取数据，但阻止其他事务获取排他锁
- 使用场景：读取数据时使用，确保数据在读取过程中不被修改，可以使用SELECT ... LOCK IN SHARE MODE语句显式加共享锁
- 兼容性：与其它共享锁兼容，与排他锁不兼容
### 排他锁（X锁/写锁）
- 特性：也是行级锁，独占锁，阻止其他事务获取任何类型的锁（包括共享锁和排他锁）
- 使用场景：插入、更新或删除数据时InnoDB会自动为涉及的行加排他锁，如果希望在读数据的时候加排他锁，需要使用SELECT ... FOR UPDATE语句显式加排他锁
- 兼容性：与任何锁都不兼容
### 意向锁
  意向锁是表锁，表示即将对某些行加锁。  
  当一个事务要对某些行加锁之前，会先对这张表加一个意向锁，作用就是提高锁冲突检测的效率。  
  没有意向锁时，事务B想加表锁，它就需要全表扫描是否有行锁；如果有意向锁，事务B只需要检查是否有意向锁，立即就可以知道自己是否可以加锁了。  
  另一个作用就是意向锁实现了表锁和行锁的共存。  
  自动加锁：InnoDB自动管理意向锁，开发者无需显式操作  
  与隔离级别关系：意向锁在所有隔离级别下都存在
### 间隙锁（Gap Lock）
- 特性：行锁的一种，锁定索引范围内的间隙
- 使用场景：防止幻读，确保在当前事务中，其他事务不能在锁定范围内插入新行
- 兼容性：与共享锁兼容，与排他锁不兼容
- 注意：间隙锁只在REPEATABLE READ和SERIALIZABLE隔离级别下使用，防止幻读

## Transactional注解
### Transactional 原理
transactional基于AOP，AOP基于JDK的动态代理机制。  
Springboot自动支持事务，无需手动配置  
Spring boot启动时，由于自动装配，会生成一个AOP切面类TransactionInterceptor。所有符合AOP规则要求的类或者方法都会进入这个切面类。  
AOP容器为使用了@Transactional注解的类创建代理，执行代理类的目标方法时，会调用Advisor类的getAdvise方法，获取TransactionInterceptor，并执行invoke方法。  
invoke方法会调用invokeWithinTransaction方法，在invokeWithinTransaction方法中，完整地实现了事务管理的功能。  
### 最佳实践建议
‌标注位置‌：始终将@Transactional注解放在‌实现类的方法上‌，避免接口标注。
‌代理配置‌：显式配置@EnableTransactionManagement(proxyTargetClass=true)强制使用CGLIB代理 。
‌异常处理‌：配合rollbackFor明确指定回滚异常类型，避免默认回滚规则导致意外行为。
### Transactional 使用注意事项
1.Transactional可以被用于类和方法，接口和接口方法，注意，当用于方法时，只有public方法事务才会被启用；当用于其他方法时，也不会报错，只是不会生效  
2.仅仅加上@Transactional是不会开启事务的，需要在配置文件中使用配置元素，才会开启事务  
3.通过配置元素的proxy-target-class来控制代理类型，如果设置为true，就使用cglib，如果设置为false或者不设置，就会忽略cglib，转而使用jdk代理  
4.在接口上使用Transactional只有设置了基于jdk的代理才会生效。 

## 3.讲一下mysql中的事务隔离级别？
mysql 的事务隔离级别一共有 4 种
1. **读未提交**：这种隔离级别会出现脏读的情况。
2. **读已提交**：这种不会出现脏读，但是会出现不可重复读。它的原理是每次提交修改的时候生成一个 readview，事务读的是 readview，这就避免了取到未提交的数据。
3. **可重复度**：这种隔离级别不会出现脏读和不可重复读，但是会出现幻读。
4. **串行**：完全不支持多个事务并发执行，避免了幻读，但是性能很差。

## 7.MySQL 是如何避免幻读的？
MySQL 通过使用锁机制来避免幻读。
在可重复读隔离级别下，MySQL 使用间隙锁（Gap Lock）来锁定范围内的记录，从而防止其他事务在该范围内插入新记录。
这样可以确保在一个事务中多次读取同一范围时，结果是一致的，不会出现幻读现象。


## 4.你知道数据库事务吗，一般是怎么使用事务的？
数据库事务是指一组操作的集合，这些操作要么全部成功，要么全部失败，保证数据的一致性和完整性。事务具有四个基本特性，简称为 ACID：
1. **原子性（Atomicity）**：事务中的所有操作要么全部成功，要么全部失败。
2. **一致性（Consistency）**：事务执行前后，数据库都处于一致的状态。
3. **隔离性（Isolation）**：不同事务之间相互隔离，互不干扰。
4. **持久性（Durability）**：一旦事务提交，数据的修改是永久性的，即使系统崩溃也不会丢失。

我一般使用 Transactional 注解来管理事务。
在方法上添加 @Transactional 注解，表示该方法需要在事务中执行。
Spring 会自动处理事务的开始、提交和回滚。

## 5.Transactional注解有失效的时候吗？如果有，是什么情况？
@Transactional 注解在以下情况下可能会失效：
1. **内部方法调用**：如果在同一个类中调用带有 `@Transactional` 注解的方法，Spring 不会拦截这个调用，因此事务不会生效。解决方法是将该方法提取到另一个类中，或者使用 AOP 代理。
2. **非 public 方法**：`@Transactional` 注解只对 public 方法有效。如果在类中使用了 `@Transactional` 注解，但方法是 private、protected 或 package-private，则事务不会生效。
3. **异常类型**：默认情况下，`@Transactional` 只会对`RuntimeException`和`Error`进行回滚。如果抛出的是受检异常（`Checked Exception`），则不会回滚事务。可以通过设置 `rollbackFor` 属性来指定需要回滚的异常类型。
4. **事务传播行为**：如果在同一个事务中调用了另一个事务方法，并且传播行为设置为 `REQUIRES_NEW`，则会创建一个新的事务，这可能导致原有事务失效。
5. **数据库引擎不支持事务**：如果使用了不支持事务的数据库引擎（如 MyISAM），则 `@Transactional` 注解不会生效。
6. **AOP 代理问题**：如果使用了 CGLIB 代理且注解放在了接口类而不是实现类，会导致事务失效。
7. **多线程环境**：在多线程环境中，如果事务方法被多个线程并发调用，可能会导致事务失效。因为每个线程都有自己的事务上下文，无法共享事务状态。
