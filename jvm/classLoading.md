# 类加载机制
类加载是Java虚拟机(JVM)将类的字节码文件(.class)加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被JVM直接使用的Java类型的过程。
## 类加载的过程
类加载的全过程分为以下5个阶段：
### 1. 加载（Loading）
加载阶段完成以下3件事：
- 通过类的全限定名获取定义此类的二进制字节流
- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
- 在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
### 2. 链接（Linking）
链接阶段包括以下3个子阶段：
#### 验证（Verification）
确保Class文件的字节流中包含的信息符合当前虚拟机要求，包括：
- 文件格式验证（魔数、版本号等）
- 元数据验证（语义分析）
- 字节码验证（程序语义合法性）
- 符号引用验证（常量池中的各种符号引用）
#### 准备（Preparation）
   为类变量（static变量）分配内存并设置初始值（零值）的阶段：
- 这时候进行内存分配的仅包括类变量，不包括实例变量
- 如果类变量是常量（final static），则会直接赋值为代码中指定的值
#### 解析（Resolution）
将常量池内的符号引用替换为直接引用的过程：
- 类或接口的解析
- 字段解析
- 类方法解析
- 接口方法解析
### 3. 初始化（Initialization）
   执行类构造器clinit()方法的过程：
- clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
- 虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁、同步
## 类加载器
1. 启动类加载器（Bootstrap ClassLoader）
- 由C++实现，是JVM的一部分
- 负责加载<JAVA_HOME>\lib目录下的核心类库
2. 扩展类加载器（Extension ClassLoader）
- 由Java实现，继承自java.lang.ClassLoader
- 负责加载<JAVA_HOME>\lib\ext目录下的扩展类库
3. 应用程序类加载器（Application ClassLoader）
- 也称为系统类加载器
- 负责加载用户类路径（ClassPath）上指定的类库
## 双亲委派模型
类加载器之间的层次关系称为双亲委派模型，工作过程如下：  
1.当一个类加载器收到类加载请求时，首先不会自己尝试加载，而是委托给父类加载器  
2.父类加载器会再委托给它的父类加载器，直到启动类加载器  
3.如果父类加载器无法完成加载（在自己的搜索范围内没找到该类），子加载器才会尝试自己加载  
优点：  
- 避免类的重复加载  
- 保证Java核心API的安全（防止核心类被随意替换）  
## 破坏双亲委派模型的情况 
1. JDK1.2之前还没有双亲委派模型  
2. JNDI、JDBC等框架使用SPI机制，通常会指定具体的类加载器进行加载
3. OSGi等模块化系统每个模块都有自己的类加载器  
4. 热部署和热更新机制，无需重启应用程序，通过自定义类加载器，直接替换已经被加载的类  
## 自定义类加载器
实现自定义类加载器通常需要：  
1.继承java.lang.ClassLoader类  
2.重写findClass()方法（推荐）或loadClass()方法（破坏双亲委派）  
3.在findClass()方法中调用defineClass()方法将字节数组转换为Class对象  