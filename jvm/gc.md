# 垃圾回收

## 如何确认垃圾对象
在垃圾回收（Garbage Collection, GC）过程中，确认哪些对象是垃圾主要依赖于以下几种方法：
#### 1. 引用计数法（Reference Counting）
- 每个对象维护一个引用计数器，当有引用指向对象时，计数器加1，当引用失效时，计数器减1，当计数器为0时，对象被视为垃圾
- 缺点：无法处理循环引用的情况
#### 2. 可达性分析法（Reachability Analysis）
   大多数现代GC采用这种方法：
- 从GC Roots（一组必须活跃的引用）开始，通过引用链遍历所有可达对象，未被遍历到的对象被视为垃圾
### GC Roots通常包括：
- 虚拟机栈中引用的对象
- 方法区中类静态变量引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象
- 虚拟机内部引用（如系统类加载器等）

## CMS与G1的区别
#### 设计目标
CMS：以最短停顿时间（低延迟）为目标，适用于对响应时间敏感的应用（如Web服务）。  
G1：在可控停顿时间的基础上，兼顾吞吐量和内存碎片控制，适合大堆内存（>4GB）的应用。
#### 堆内存管理方式
CMS：  
物理分代：严格划分新生代（Eden、Survivor）和老年代，内存连续。  
算法：采用标记-清除（Mark-Sweep），会产生内存碎片，可能导致Full GC。  
G1：  
逻辑分代：将堆划分为多个Region（默认2048个），每个Region可以是Eden、Survivor或Old区，物理上不连续。  
算法：整体基于标记-整理（Mark-Compact），局部使用复制算法，减少碎片。  
#### 回收过程
| 阶段 | CMS | G1                   |
|---| --- |----------------------|
| 初始标记 | STW，标记GC Roots直接关联对象 | STW，同CMS但记录SATB快照    |
| 并发标记 | 与用户线程并行，记录SATB快照 | 并发标记，计算Region回收价值    |
| 重新标记 | STW，修正并发标记的变动（增量更新） | STW，处理SATB记录的引用变化    |
| 清理/回收 | 并发清理（产生浮动垃圾） | 按Region优先级回收（复制存活对象） |

## ZGC
ZGC（Z Garbage Collector）是JDK 11引入的一种低延迟垃圾收集器，设计目标是实现毫秒级的停顿时间，适用于大堆内存（多达数TB）的应用。
#### 主要特点
- **低延迟**：停顿时间通常在10ms以内，适合对响应时间要求极高的应用。
- **可扩展性**：支持从几百MB到数TB的堆内存。
- **并发执行**：大部分GC工作与应用线程并发进行，减少停顿时间。
- **区域化内存管理**：将堆划分为多个区域（Region），每个区域可以独立回收。
- **指针压缩**：在大堆内存中使用指针压缩技术，减少内存占用。
#### 工作原理
- **标记阶段**：使用多线程并发标记所有可达对象，并记录对象的引用关系。
- **重新标记阶段**：STW，修正并发标记期间的引用变化。
- **回收阶段**：并发地将存活对象移动到新的区域，释放未使用的内存区域。
#### 使用场景
- 适用于对延迟敏感且堆内存较大的应用，如大型Web服务、实时数据处理系统等。

## 强引用、软引用、弱引用、虚引用的GC影响
强引用：所有new出来的对象都是强引用，GC永不回收  
软引用：GC时如果内存不足，会被回收  
弱引用：GC时无论内存是否不足，都会被回收  
虚引用：主要用于资源清理跟踪
