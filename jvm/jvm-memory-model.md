# JVM内存模型
### 1. 程序计数器
- 线程私有：每个线程都有独立的程序计数器
- 作用：记录当前线程执行的字节码指令地址
- 特点：
  - 如果执行的是Native方法，计数器值为空（Undefined）
  - 此区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域
### 2. Java虚拟机栈
- 线程私有：生命周期与线程相同
- 作用：存储栈帧（Stack Frame），用于方法调用和执行
- 栈帧组成：
  - 局部变量表（Local Variables）
  - 操作数栈（Operand Stack）
  - 动态链接（Dynamic Linking）
  - 方法返回地址（Return Address）
  - 附加信息
- 异常：
- StackOverflowError：栈深度超过限制（通常由无限递归引起）
- OutOfMemoryError：无法申请到足够内存扩展栈
### 3. 本地方法栈
- 线程私有
- 作用：为Native方法服务
### 4. Java堆
- 线程共享：所有线程共享的运行时数据区
- 作用：存放对象实例和数组
- 特点：
  - GC管理的主要区域
  - 可以物理上不连续，但逻辑上连续
  - 现代JVM大多采用分代收集算法
- 异常：OutOfMemoryError（堆中没有足够内存完成实例分配）
### 5. 方法区
- 线程共享
- 作用：存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码
- 实现：
  - JDK7及之前：永久代（PermGen）
  - JDK8及之后：元空间（Metaspace，使用本地内存）
- 异常：OutOfMemoryError（方法区无法满足内存分配）

## 堆内存如何设计
#### 最佳实践
- 通常不超过物理内存的70-80%
- 新生代大小通常占总的1/3到1/2，短命对象多，新生代占比可增大(占堆40-50%)，对于缓存型应用：减小新生代(占堆25-33%)  
- Eden区是Survivor区的8倍  
- 初始大小和最大大小设置相同  
- GC的理想情况：Young GC在50-150ms，Full GC极少发生  
#### 调优流程示例
  1.初始配置中等大小堆内存  
  2.使用负载测试工具模拟真实场景  
  3.收集GC日志  
  4.使用工具分析GC日志  
  5.根据分析结果调整：
- 如果频繁Full GC：增加总堆或老年代大小
- 如果Young GC频繁但短暂：增大Eden区
- 如果Young GC耗时长：考虑减小新生代
