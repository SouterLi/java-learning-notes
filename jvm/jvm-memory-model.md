# JVM内存模型
### 1. 程序计数器
- 作用：记录当前线程执行的字节码指令地址
- 特点：
  - 如果执行的是Native方法，计数器值为空（Undefined）
  - 线程私有
  - 此区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域
### 2. Java虚拟机栈
- 线程私有
- 作用：存储栈帧，用于方法调用和执行
- 栈帧组成：局部变量表，操作数栈，动态链接，方法返回地址，附加信息
- 异常：
- StackOverflowError：栈深度超过限制（通常由无限递归引起）
- OutOfMemoryError：无法申请到足够内存扩展栈
### 3. 本地方法栈
- 线程私有
- 作用：格式与虚拟机栈类似，专门为本地方法服务
### 4. Java堆
- 线程共享
- 作用：存放对象实例和数组，String也在这里
- 特点：
  - GC管理的主要区域
  - 可以物理上不连续，但逻辑上连续
  - 现代JVM大多采用分代收集算法
- 异常：OutOfMemoryError（堆中没有足够内存完成实例分配）
### 5. 方法区
- 线程共享
- 作用：存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码
- 实现：JDK7及之前：永久代；JDK8及之后：元空间，使用堆外内存
- 异常：OutOfMemoryError（方法区无法满足内存分配）

## 堆内存如何设计
#### 最佳实践
- 通常不超过物理内存的70-80%
- 新生代大小通常占总的1/3到1/2，短命对象多，新生代占比可增大(占堆40-50%)，对于缓存型应用：减小新生代(占堆25-33%)  
- Eden区是Survivor区的8倍  
- 初始大小和最大大小设置相同  
- GC的理想情况：Young GC在50-150ms，Full GC极少发生  
#### 调优流程示例
  1.初始配置中等大小堆内存  
  2.使用负载测试工具模拟真实场景  
  3.收集GC日志  
  4.使用工具分析GC日志  
  5.根据分析结果调整：
- 如果频繁Full GC：增加总堆或老年代大小
- 如果Young GC频繁但短暂：增大Eden区
- 如果Young GC耗时长：考虑减小新生代

## String类型的数据存储在什么地方？
如果这个String是一个字面量，那么它会存储在方法区的字符串常量池中，字符串常量池在Java8以后在堆中；如果这个String是通过new关键字创建的，那么它会存储在堆内存中。
无论是哪种情况，这个String字符串的**实际引用**都是在堆中的；
无论是哪种情况，这个String字符串的**符号引用**都是存储在方法区的运行时常量池中的，它不在堆中。